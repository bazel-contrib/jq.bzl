"Provide access to a jq binary via Bazel's toolchains feature"

load("@bazel_lib//lib:repo_utils.bzl", "repo_utils")
load(":platforms.bzl", "JQ_PLATFORMS")

TOOLCHAIN_TYPE = "@jq.bzl//jq/toolchain:type"
DEFAULT_JQ_REPOSITORY = "jq"
DEFAULT_JQ_VERSION = "1.7"

JqInfo = provider(
    doc = "Provide info for executing jq",
    fields = {
        "bin": "Executable jq binary",
    },
)

def _jq_toolchain_impl(ctx):
    binary = ctx.file.bin

    # Make the $(JQ_BIN) variable available in places like genrules.
    # See https://docs.bazel.build/versions/main/be/make-variables.html#custom_variables
    template_variables = platform_common.TemplateVariableInfo({
        "JQ_BIN": binary.path,
    })
    default_info = DefaultInfo(
        files = depset([binary]),
        runfiles = ctx.runfiles(files = [binary]),
    )
    jq_info = JqInfo(
        bin = binary,
    )

    # Export all the providers inside our ToolchainInfo
    # so the resolved_toolchain rule can grab and re-export them.
    toolchain_info = platform_common.ToolchainInfo(
        jqinfo = jq_info,
        template_variables = template_variables,
        default = default_info,
    )

    return [default_info, toolchain_info, template_variables]

jq_toolchain = rule(
    implementation = _jq_toolchain_impl,
    attrs = {
        "bin": attr.label(
            mandatory = True,
            allow_single_file = True,
        ),
    },
)

def _jq_toolchains_repo_impl(rctx):
    # Expose a concrete toolchain which is the result of Bazel resolving the toolchain
    # for the execution or target platform.
    # Workaround for https://github.com/bazelbuild/bazel/issues/14009
    # TODO: remove when support for Bazel 8 and earlier is dropped.
    starlark_content = """# @generated by @bazel_lib//lib/private:jq_toolchain.bzl

# Forward all the providers
def _resolved_toolchain_impl(ctx):
    toolchain_info = ctx.toolchains["{0}"]
    return [
        toolchain_info,
        toolchain_info.default,
        toolchain_info.jqinfo,
        toolchain_info.template_variables,
    ]

# Copied from java_toolchain_alias
# https://cs.opensource.google/bazel/bazel/+/master:tools/jdk/java_toolchain_alias.bzl
resolved_toolchain = rule(
    implementation = _resolved_toolchain_impl,
    toolchains = ["{0}"],
)
""".format(TOOLCHAIN_TYPE)
    rctx.file("defs.bzl", starlark_content)

    build_content = """# @generated by @bazel_lib//lib/private:jq_toolchain.bzl
#
# These can be registered in the workspace file or passed to --extra_toolchains flag.
# By default all these toolchains are registered by the jq_register_toolchains macro
# so you don't normally need to interact with these targets.

load(":defs.bzl", "resolved_toolchain")

resolved_toolchain(name = "resolved_toolchain", visibility = ["//visibility:public"])

"""

    for [platform, meta] in JQ_PLATFORMS.items():
        build_content += """
toolchain(
    name = "{platform}_toolchain",
    exec_compatible_with = {compatible_with},
    toolchain = "@{user_repository_name}_{platform}//:jq_toolchain",
    toolchain_type = "{toolchain_type}",
)
""".format(
            platform = platform,
            user_repository_name = rctx.attr.user_repository_name,
            compatible_with = meta.compatible_with,
            toolchain_type = TOOLCHAIN_TYPE,
        )

    # Base BUILD file for this repository
    rctx.file("BUILD.bazel", build_content)

jq_toolchains_repo = repository_rule(
    _jq_toolchains_repo_impl,
    doc = """Creates a repository with toolchain definitions for all known platforms
     which can be registered or selected.""",
    attrs = {
        "user_repository_name": attr.string(doc = "Base name for toolchains repository"),
    },
)

def _jq_host_alias_repo(rctx):
    ext = ".exe" if repo_utils.is_windows(rctx) else ""

    # Base BUILD file for this repository
    rctx.file("BUILD.bazel", """# @generated by @bazel_lib//lib/private:jq_toolchain.bzl
package(default_visibility = ["//visibility:public"])
exports_files(["jq{ext}"])
""".format(
        ext = ext,
    ))

    rctx.symlink("../{name}_{platform}/jq{ext}".format(
        name = rctx.attr.name,
        platform = repo_utils.platform(rctx),
        ext = ext,
    ), "jq{ext}".format(ext = ext))

jq_host_alias_repo = repository_rule(
    _jq_host_alias_repo,
    doc = """Creates a repository with a shorter name meant for the host platform, which contains
    a BUILD.bazel file that exports symlinks to the host platform's binaries
    """,
)
